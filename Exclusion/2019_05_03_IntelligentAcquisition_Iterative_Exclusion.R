##remove all R objects from memory, this program can be memory intensive as it is dealing with huge datasets
rm(list = ls())
waters=TRUE #are you using waters (may not be applicable to all instruments (applicable to some thermo and waters instruments), and hence exclusion list may need to be reformatted)
thermoQE=FALSE #thermo? (formatted for Q-Exactive, some instruments require different formats)
thermoLumos=FALSE #thermo? (formatted for Lumos Fusion, some instruments require different formats)
if ((thermoQE | thermoLumos)==TRUE){
  thermo<-TRUE
} else {thermo<-FALSE}
# if("dplyr" %in% rownames(installed.packages()) == FALSE) {install.packages("dplyr")}
# if("rgeos" %in% rownames(installed.packages()) == FALSE) {install.packages("rgeos")}
# if("sp" %in% rownames(installed.packages()) == FALSE) {install.packages("sp")}
if("mzR" %in% rownames(installed.packages()) == FALSE) {install.packages("mzR")}
if("gWidgets" %in% rownames(installed.packages()) == FALSE) {install.packages("gWidgets")}
if("gWidgetstcltk" %in% rownames(installed.packages()) == FALSE) {install.packages("gWidgetstcltk")}
if("BiocManager" %in% rownames(installed.packages()) == FALSE) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
}
require(gWidgets)
require(gWidgetstcltk)
require(mzR)
# require(dplyr)
# require(rgeos)
# require(sp)
options(guiToolkit="tcltk")
inputMS1 <- choose.files(caption="import .mzML file with full scan data \nto be used to generate exclusion lists \n for MSConvert parameters (conversion of vendor file)\n See the help manual. \n Note that files will be exported to this directory \n in new folder(s) generated by the software",multi=FALSE)
OutputDirectory <- paste(dirname(inputMS1),"/",sep="")
DefaultSettings = ginput(message="Use default settings? type 'y' or 'n' (no quotes)", title="Use Default Settings? (y/n)",icon="question")
if (DefaultSettings != "n") {
  ##User inputs
  if (waters == TRUE) {
    maxExclSize<-100
  }
  if (thermo == TRUE) {
    maxExclSize<-5000
  }
  topN<-5
  maxExclLists<-6
  RTWindow = .1 # For a selected ion in current injection, exclude ion within this retention time window of that ion in following injections
  PercentNoiseThreshold = .1 # The minimum percent of scans (entire RT range) containing a specific m/z for that m/z to be considered noise
} else {
  topN<-ginput(message="topN most abundant ions selected for fragmentation \nthis should match the settings in your instrument methods file", title="topN (integer)",icon="question")
  maxExclSize<-ginput(message="The maximum size of an exclusion list\ncertain vendors have limits to the size of an exclusion list\nwater is 100, thermo Q-Exactive is 5000, and the Lumos Fusion does not have a limit.\nplease consult the vendor help documents to determine the maximum for other instruments", title="maximum exclusion list size",icon="question")
  maxExclLists<-ginput(message="the maximum number of exclusion lists to generate. \nGenerally 5-6 will give you near complete coverage in positive mode, and 2-3 in negative mode\n But it depends on spectral density and the number of injections you can afford", title="maximum number of exclusion lists (integer)",icon="question")
  RTWindow<-ginput(message="the window to combine retention times of top m/z values. For thermo this will also be the window to exclude ions \nA suggested value if you are not sure is 0.1 minutes, \nmany adjacent peaks will often be combined so the resulting exclusion window (minutes) will be much wider", title="retention time window (number)",icon="question")
  PercentNoiseThreshold<-ginput(message="The minimum percent of scans (entire RT range) containing a specific m/z\n for that m/z to be considered noise. \nvalue from 0 to 1 (1 being 100%, or that the m/z would have to appear in every single scan as a topN hit) \nSuggested default 0.1", title="Percent Noise Threshold (0 - 1)",icon="question")
  topN<-as.numeric(topN)
  maxExclSize<-as.numeric(maxExclSize)
  maxExclLists<-as.numeric(maxExclLists)
  RTWindow<-as.numeric(RTWindow) # For a selected ion in current injection, exclude ion within this retention time window of that ion in following injections
  PercentNoiseThreshold<-as.numeric(PercentNoiseThreshold)
  
}


MS1<-openMSfile(inputMS1, backend = NULL, verbose = FALSE)
MS1Spectra<-spectra(MS1)
MS1RetentionTime<-header(MS1)[,7]
#automatically detect polarity and max RT
polarity <- if (header(MS1)[1,4]==1) {"positive"} else {"negative"}
maxRT <- max(MS1RetentionTime)/60
#empty matrix for multiple exclusion lists (RT, MZ, Intensity)
ExclLists<-matrix(0,length(MS1RetentionTime)*topN,maxExclLists*2+1)

# For reference, add the correct column names to the empty matrix for filling with exclusion list values
colnames(ExclLists)<-1:((maxExclLists*2)+1)
colnames(ExclLists)[1]<-"RT"
a<-1
for (i in 1:maxExclLists) {
  colnames(ExclLists)[a:(i*2)+1]<-c(paste("mz",i,sep=""),paste("Int",i,sep=""))
  a<-i*2+1
}
a<-1
# go through each (i) MS scans to find top N components
for (i in 1:length(MS1RetentionTime)) {
  #fill retention times
  ExclLists[a:(a+topN-1),1]<-MS1RetentionTime[i]
  CurrentSpectra<-MS1Spectra[[i]]
  #Sort by intensity
  CurrentSpectra<-CurrentSpectra[order(CurrentSpectra[,2],decreasing = TRUE),]
  #go through top n compenents x times (the number of exclusion lists generated)
  for (x in 1:maxExclLists) {
    # In the case where the current length of the spectra is shorter than the topN
    if ((length(CurrentSpectra)/2)<(x*topN+1)) {
      #In the case where the spectra is > 1 (so it is a matrix)
      if((length(CurrentSpectra)/2)>1) {
        endRowExcl<-a+(length(CurrentSpectra)/2)-1-(x-1)*topN
        endRowSpectra<-length(CurrentSpectra)/2
        ExclLists[a:endRowExcl,(x*2):(x*2+1)]<-CurrentSpectra[(x*topN-(topN-1)):endRowSpectra,]
        break
        # in the case where it is only 1 value (not a matrix, so needs special attention)
      } else {
        endRowExcl<-a+(length(CurrentSpectra)/2)-1
        ExclLists[a:endRowExcl,(x*2):(x*2+1)]<-CurrentSpectra[]
        break
      }
      #In all other cases where you still have the total peaks to fill the topN exclusion list
    } else {
      #fill in m/z and intensity values of topN m/z's by intensity for x exclusion lists
      ExclLists[a:(a+topN-1),(x*2):(x*2+1)]<-CurrentSpectra[(x*topN-(topN-1)):(x*topN),]
      #Break out of loop in the case where you have exactly reached the topN and there are no more topN
      if(((x*topN-topN)-length(CurrentSpectra)/2)==0) {
        break
      }
    }
  }
  a<-a+topN
}
#header for for thermo formatted exclusion list (Q-Exactive)
ExclusionTable1 = matrix(0,nrow(ExclLists),9)
colnames(ExclusionTable1) = c("Mass [m/z]", "Formula [M]", "Formula type", "Species", "CS [z]", "Polarity", "Start [min]", "End [min]", "Comment")
#Fill in m/z and RT values for first exclusion list
ExclusionTable1[,1] = ExclLists[,2]
ExclusionTable1[,7] = (ExclLists[,1]/60)-(RTWindow/2)
ExclusionTable1[,8] = (ExclLists[,1]/60)+(RTWindow/2)
ExclLists_Formatted = list(ExclusionTable1)
for (i in 2:maxExclLists) {
  ExclusionTable = matrix(0,nrow(ExclLists),9)
  colnames(ExclusionTable) = c("Mass [m/z]", "Formula [M]", "Formula type", "Species", "CS [z]", "Polarity", "Start [min]", "End [min]", "Comment")
  #Fill in m/z and RT values for first exclusion list
  ExclusionTable[,1] = ExclLists[,i*2]   #m/z's
  ExclusionTable[,7] = (ExclLists[,1]/60)-(RTWindow/2)   #RTs (start)
  ExclusionTable[,8] = (ExclLists[,1]/60)+(RTWindow/2)   #RTs
  ExclusionTable1<-rbind(ExclusionTable1,ExclusionTable) #combine previous and current exclusion list
  ExclLists_Formatted[[i]] = ExclusionTable1
}
#sort exclusion lists by m/z
for (i in 1:length(ExclLists_Formatted)) {
  ExclLists_Formatted[[i]]<-ExclLists_Formatted[[i]][order(as.numeric(ExclLists_Formatted[[i]][,1]),decreasing = FALSE),] #sort exclusion list by m/z
}
filterComment = "background"
#if the peak shows up as a top peak in 20% (default) or more of the scans it is noise
noiseCount <- length(MS1RetentionTime)*PercentNoiseThreshold
#Reduce data set (exclude 0's, combine background ions, set negative retention times to 0)
for (i in 1:length(ExclLists_Formatted)) {
  #eliminate 0's, round m/z's, and sort by RT
  ExclLists_Formatted[[i]]<-ExclLists_Formatted[[i]][ExclLists_Formatted[[i]][,1]!=0,] #remove 0's
  ExclLists_Formatted[[i]][,1]<-round(ExclLists_Formatted[[i]][,1],1) #round m/z in order that m/z can be binned within 0.1 mass units
  #get unique m/z values
  MZvalues = ExclLists_Formatted[[i]][,1]
  uniqueVals = unique(MZvalues)
  #Replace 0's with "" (blank cells)
  ExclLists_Formatted[[i]][,c(2:6,9)]<-""
  #replace negative retention times with 0
  NegativeRT<-which(as.numeric(ExclLists_Formatted[[i]][,7])<0)
  ExclLists_Formatted[[i]][NegativeRT,7]<-0
  for (x in 1:length(uniqueVals)) {
    #if the number of a certain m/z is over the threshold number of scans, combine and exclude for the entire chromatographic range
    if(length(MZvalues[MZvalues == uniqueVals[x]]) > noiseCount){
      ExclLists_Formatted[[i]] = ExclLists_Formatted[[i]][as.numeric(ExclLists_Formatted[[i]][,1])!=uniqueVals[x],]
      ExclLists_Formatted[[i]] = rbind(ExclLists_Formatted[[i]], matrix(c(uniqueVals[x], "", "", "", "", "", 0, maxRT, filterComment), nrow=1))
    }
  }
}
#sort by m.z, than RT
for (i in 1:length(ExclLists_Formatted)) {
  ExclLists_Formatted[[i]]<-ExclLists_Formatted[[i]][order(as.numeric(ExclLists_Formatted[[i]][,7]),decreasing = FALSE),] #sort exclusion list by m/z
  ExclLists_Formatted[[i]]<-ExclLists_Formatted[[i]][order(as.numeric(ExclLists_Formatted[[i]][,1]),decreasing = FALSE),] #sort exclusion list by RT
}

##Data cleaning - compresses MZs based on overlapping RT for a more compact and readable exclusion List
for (i in 1:length(ExclLists_Formatted)) {
  MZvalues = as.numeric(ExclLists_Formatted[[i]][,1])
  row = 2
  for (j in unique(MZvalues)){
    loopSize = length(which(MZvalues == j))
    #print(loopSize)
    k = 1
    while(k < loopSize){
      if((as.numeric(ExclLists_Formatted[[i]][row,7]) <= as.numeric(ExclLists_Formatted[[i]][row-1,8]))) { #RT Min
        ExclLists_Formatted[[i]][row-1,8] = ExclLists_Formatted[[i]][row,8]
        ExclLists_Formatted[[i]] = ExclLists_Formatted[[i]][-row, ]
        row = row - 1
      }
      k = k + 1
      row = row + 1
    }
    row = row + 1
  }
}
if(thermoQE==TRUE) {
  BGcol<-9
  RTcol<-7
}
if(waters==TRUE) {
  BGcol<-3
  RTcol<-2
  for (i in 1:length(ExclLists_Formatted)) {
    watersExclMatrix<-matrix(0,nrow(ExclLists_Formatted[[i]]),3) #create empty matrix for water (n rows by 3 columns)
    watersExclMatrix[,1]<-as.numeric(ExclLists_Formatted[[i]][,1]) #add m/z values
    #add means of retention times (converted to seconds)
    watersExclMatrix[,2]<-((as.numeric(ExclLists_Formatted[[i]][,7])+as.numeric(ExclLists_Formatted[[i]][,8]))/2)*60
    #0 for background ion (meaning exclude for all RT), 1 for non-background ion (exclude within a user set threshold)
    watersExclMatrix[which(ExclLists_Formatted[[i]][,9] == "background")-1,2]<-0
    watersExclMatrix[which(ExclLists_Formatted[[i]][,9] == "background")-1,3]<-0
    watersExclMatrix[which(ExclLists_Formatted[[i]][,9] != "background")-1,3]<-1
    ExclLists_Formatted[[i]]<-watersExclMatrix
  }
}
if(thermoLumos==TRUE) {
  BGcol<-2
  RTcol<-3
  for (i in 1:length(ExclLists_Formatted)) {
    lumosExclMatrix<-matrix(0,nrow(ExclLists_Formatted[[i]]),4) #create empty matrix for lumos (n rows by 3 columns)
    colnames(lumosExclMatrix) = c("m/z","Name","t start (min)","stop (min)")
    lumosExclMatrix[,1]<-as.numeric(ExclLists_Formatted[[i]][,1]) #add m/z values
    #add start and end RT (min)
    lumosExclMatrix[,3]<-as.numeric(ExclLists_Formatted[[i]][,7])
    lumosExclMatrix[,4]<-as.numeric(ExclLists_Formatted[[i]][,8])
    #background ions
    lumosExclMatrix[,2]<-ExclLists_Formatted[[i]][,9]
    ExclLists_Formatted[[i]]<-lumosExclMatrix
  }
}
setwd(OutputDirectory)
dir.create("ExclusionLists")
OutputDirectory<-paste(OutputDirectory,"ExclusionLists/",sep="")
#Code to split up tables if you have over the amount the instrument can handle
for (i in 1:length(ExclLists_Formatted)) {
  if (nrow(ExclLists_Formatted[[i]])<=maxExclSize) { #in the case where the number of elements is less than or equal to the maximum exclusion list size
    #Simply export each file
    write.table((ExclLists_Formatted[[i]]),  paste(OutputDirectory,"ExclList_",polarity,i,".csv",sep=""), sep=",", col.names=TRUE, row.names=FALSE, quote=TRUE, na="NA")
  } else { #In the case the exclusion list is too large
    BackgroundIons<-ExclLists_Formatted[[length(ExclLists_Formatted)]][ExclLists_Formatted[[length(ExclLists_Formatted)]][,BGcol]=="background",]
    #how many times do you need to split the exclusion list to have appropriately sized sub-lists?
    SplitExclLists<-ceiling(nrow(ExclLists_Formatted[[i]])/maxExclSize)
    #Include now the fact you will append all background ions on all exclusion lists
    # SplitExclLists<-ceiling((nrow(ExclLists_Formatted[[i]])+(SplitExclLists-1)*nrow(BackgroundIons))/maxExclSize)
    StartRow<-1
    #Save each sub-setted list based on retention time order (also add all background ions to every exclusion list)
    for (x in 1:(SplitExclLists)) {
      #Sort by RT
      ExclLists_Formatted[[i]]<-ExclLists_Formatted[[i]][order(as.numeric(ExclLists_Formatted[[i]][,RTcol]),decreasing = FALSE),] #sort exclusion list by retention time
      EndRow<-floor((nrow(ExclLists_Formatted[[i]])/SplitExclLists)*x)
      TempExcl<-ExclLists_Formatted[[i]][StartRow:EndRow,]
      #remove background ions on current exclusion list
      if (waters ==TRUE) {
        TempExcl<-TempExcl[TempExcl[,BGcol]!=0,]
      } else {
        TempExcl<-TempExcl[TempExcl[,BGcol]!="background",]
      }
      #append all background ions
      TempExcl<-rbind(TempExcl,BackgroundIons)
      if (waters == TRUE) {
        write.table(TempExcl,paste(OutputDirectory,"ExclList_",polarity,i,"_Split_",x,".txt",sep=""), sep=",", col.names=FALSE, row.names=FALSE, quote=TRUE, na="NA")
      } else {
        write.table(TempExcl,paste(OutputDirectory,"ExclList_",polarity,i,"_Split_",x,".csv",sep=""), sep=",", col.names=TRUE, row.names=FALSE, quote=TRUE, na="NA")
      }
      StartRow<-EndRow+1
    }
  }
}
